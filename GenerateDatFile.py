import os
import sys
import argparse
import re
import pandas as pd

def lNum(i): return i + 1 # Convert line index to line number

def GenerateDatFile(screen, locFile=None, outPath=None, fixScreen=True):
	strings = None
	if locFile:
		# Load original strings
		# TODO: Deal with bad lines
		strings = pd.read_table(locFile,
								encoding='utf-16',
								delimiter='\t',
								index_col=0,
								names=['ID', 'String'],
								on_bad_lines='skip')

		assert strings is not None


	# Process the screen file
	print(f'\n[INFO] Processing: "{screen}"')
	IDs, limits, newStrings = parseScreenStrings(screen, strings, fixScreen)


	name = os.path.splitext(os.path.basename(screen))[0]
	path = f'Text.UI.{name}.dat'

	# Output the dat file in the current directory if no output path is specified
	if outPath: path = os.path.join(outPath, path)


	with open(path, 'w') as file:
		file.write(datFileHeader(name, limits))

		file.write(f'rangestart {limits[0]} {limits[1]}\n')

		# Where the IDs generated by us start
		newIDsStart = max(IDs) - len(newStrings) + 1

		for ID in IDs:
			if ID >= newIDsStart:
				# Add new strings directly instead of trying to look up the IDs
				file.write(f'{ID}\t{newStrings[ID - newIDsStart][1]}\n')
			elif strings is not None:
				if ID in strings.index:	file.write(f'{ID}\t{strings.loc[ID].item()}\n')
				else:					file.write(f'{ID}\t${ID} - Does not exist\n')
			else:
				file.write(f'{ID}\t${ID}\n')

		file.write('rangeend\n')


	print(f'[INFO] Generated: "{path}"')


def parseScreenStrings(screen, strings=None, fixScreen=False):
	textEntry = re.compile(r'(\s*)text = "(.+)"')
	stringID = re.compile(r'\$(\d+)')

	with open(screen) as file:
		lines = file.readlines()
		LE = file.newlines

	IDs = []
	newStrings = []
	needsFixing = False

	# Extract all string IDs used in the file
	for i, line in enumerate(lines):
		if textMatch := textEntry.match(line):
			if idMatch := stringID.match(textMatch[2]):
				IDs.append(int(idMatch[1]))
			else:
				# This can cause issues when using UI editor (I think)
				print(f'[WARNING] String literal in text entry on line {lNum(i)}: {textMatch[0].strip()}')
				needsFixing = True

				if fixScreen:
					if (strings is not None) and (textMatch[2] in strings['String'].values):
						# This horrible looking line simply gets the index of the first occurrence
						# of textMatch[2] (i.e. the text that's in-between " & ") in the 'strings' DataFrame
						newID = strings.index.values[strings['String'] == textMatch[2]][0]

						print(f'Substituting "{textMatch[2]}" with ${newID}')

						# Replace the string with an existing string ID
						lines[i] = re.sub(textEntry, rf'\1text = "${newID}"', line)
						IDs.append(int(newID))

					else:
						# Make a note of the string so that we can add it to the end of the dat file
						newStrings.append((i, textMatch[2]))


	# If we have detected string literals that aren't original strings then Generate IDs for them
	if newStrings:
		newID = max(IDs)
		for i, string in newStrings:
			newID += 1
			lines[i] = re.sub(textEntry, rf'\1text = "${newID}"', lines[i])
			IDs.append(int(newID))

			print(f'Assigning new ID [{newID}] for "{string}" (line {lNum(i)})')



	IDs = list(set(IDs))
	IDs.sort()
	limits = roundRange(min(IDs), max(IDs))


	# Get the screen's "LocaleRange"
	start = r'^\t*'
	for i in range(len(lines)-3, -1, -1): # Searching in reverse since the range is at the end of the file
		# print(bool(re.match(re.compile('^\t\tLocaleRange =  '), lines[i])), lines[i])
		if re.match(re.compile('^\t\tLocaleRange =  '), lines[i]):
			localeRange = re.match(r'(?m)' + \
								   start + r'\{\n' + \
								   start + r'(\d+),\n' + \
								   start + r'(\d+),\n' + \
								   start + r'\},\n',
								   "".join(lines[i+1:i+5]))

			rangePos = (i+2, i+3) # Line numbers of the range values
			break


	if  localeRange is None: raise Exception('[ERROR] Could not find "LocaleRange"')

	if (localeRange[1], localeRange[2]) != limits:
		needsFixing = True
		if fixScreen:
			print('[INFO] Updating LocaleRange:', (int(localeRange[1]), int(localeRange[2])), '->', limits)

			lines[rangePos[0]] = re.sub(r'\d+', str(limits[0]), lines[rangePos[0]])
			lines[rangePos[1]] = re.sub(r'\d+', str(limits[1]), lines[rangePos[1]])

		else: print('[WARNING] New "LocaleRange" does not match the range in the Screen file')


	if needsFixing:
		if fixScreen:
			print(f'[INFO] Overwriting: "{screen}"')
			with open(screen, 'w') as file:
				file.writelines(l[:-1] + LE for l in lines) # Preserve the line endings
		else:
			print('[INFO] Errors detected in the screen file. You can fix them by passing "--fix" to this script.')


	return IDs, limits, newStrings


def roundRange(_min, _max):
	# Round down to nearest fifty
	start = (_min // 50) * 50
	end   = (_max // 50) * 50

	# Round up unless it divides equally
	if (_max % 50) != 0: end += 50

	# The range has to end on 1 less than a multiple of 50
	end -= 1
	return (start, end)



def datFileHeader(name, limits):
	# Dat file boiler plate
	header = '/' * 69 + '\n'
	header += '// Generated with CLUIE\n\n'
	header += f'filerange {limits[0]} {limits[1]}\n\n'
	header += '/' * 69 + '\n' # nice
	header += f'// UI Screen: {name}\n\n'
	return header



def getScreenFiles(paths):
	# Get all valid screen file paths from command line arguments
	screens = []
	for path in paths:
		if os.path.isfile(path):
			if path.endswith('.screen'):
				screens.append(path)
			else:
				print(f'[ERROR] Not a screen file: "{path}"')

		elif os.path.isdir(path):
			for entry in os.scandir(path):
				if entry.name.endswith('.screen') and entry.is_file():
					screens.append(entry.path)

		else:
			print(f'[ERROR] The path does not exist: "{path}"')

	return screens



if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='Generates .dat file (for UI editor) from a .screen file. Also detects and fixes invalid strings in screen files.')

	parser.add_argument('paths',
						nargs='+',
						help='Path(s) to the screen files or directory(ies) containing screen files')

	parser.add_argument('-d', '--dest',
						help='Output directory for the .dat file (e.g. UIEditor/BIA/Root/CoH/Locale/English)',
						metavar='outPath')

	parser.add_argument('-l', '--locFile',
						default=os.path.expandvars('$FERAL_SVN_DATA_ROOT/CompanyOfHeroes/Data/CompanyOfHeroesData/Data/coh/engine/locale/english/reliccoh.english.ucs'),
						help='Localisation file containing original strings',
						metavar='locFile')

	parser.add_argument('--fix', '--auto-fix',
						action=argparse.BooleanOptionalAction,
						help='Fix the errors in the screen file (overrides original screen file)')

	args = parser.parse_args()


	# Validate parameters
	if args.dest and not os.path.isdir(args.dest):
		print(f'[ERROR] Directory does not exist: "{args.dest}"')
		sys.exit()

	if args.locFile:
		if not os.path.isfile(args.locFile):
			print(f'[ERROR] File does not exist: "{args.locFile}"')
			sys.exit()

		elif not args.locFile.endswith('.ucs'):
			print(f'[ERROR] Not a localisation (.ucs) file: "{args.locFile}"')
			sys.exit()

	if args.fix and not args.locFile:
		print(f'[WARNING] Fixing screens without localisation file is not recommended (May result in the game displaying different string to the UI editor).')


	for screen in getScreenFiles(args.paths):
		GenerateDatFile(screen, args.locFile, args.dest, args.fix)


