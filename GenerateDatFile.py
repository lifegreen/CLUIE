import os
import sys
import argparse
import re
import pandas as pd

def lNum(i): return i + 1 # Convert line index to line number

def GenerateDatFile(screen, locFile=None, outPath=None, fixScreen=True):
	strings = None
	if locFile:
		# TODO: Deal with bad lines
		strings = pd.read_table(locFile
								, encoding='utf-16'
								, delimiter='\t'
								, index_col=0
								, names=['ID', 'String']
								, on_bad_lines='skip'
								)


	# Process the screen file
	print(f'\n[INFO] Processing "{screen}"')
	IDs, newStrings = getStringIDs(screen, strings, fixScreen)
	IDs, limits = getRange(IDs)

	name = os.path.splitext(os.path.basename(screen))[0]
	path = f"Text.UI.{name}.dat"

	# Output the dat file in the current directory if no output path is specified
	if outPath: path = os.path.join(outPath, path)

	with open(path, 'w') as file:
		file.write(datFileHeader(name, limits))

		file.write(f"rangestart {limits[0]} {limits[1]}\n")

		# Where the IDs generated by us start
		newIDsStart = max(IDs) - len(newStrings) + 1

		for ID in IDs:
			if ID >= newIDsStart:
				# Add new strings directly instead of trying to look up the IDs
				file.write(f"{ID}\t{newStrings[ID - newIDsStart][1]}\n")
			elif strings is not None:
				if ID in strings.index:	file.write(f"{ID}\t{strings.loc[ID].item()}\n")
				else:					file.write(f"{ID}\t${ID} - Doesn't exist\n")
			else:
				file.write(f"{ID}\t${ID}\n")

		file.write("rangeend\n")

	print(f'[INFO] Generated "{path}"')


def getStringIDs(screen, strings=None, fixScreen=False):
	textEntry = re.compile(r'(\s*)text = "(.+)"')
	stringID = re.compile(r'\$(\d+)')

	with open(screen) as file:
		lines = file.readlines()

	ids = []
	newStrings = []
	needsFixing = False
	for i, line in enumerate(lines):
		if textMatch := textEntry.match(line):
			if idMatch := stringID.match(textMatch[2]):
				ids.append(int(idMatch[1]))
			else:
				# This can cause issues when using UI editor (I think)
				print(f'[Warning] String literal in text entry on line {lNum(i)}: {textMatch[0].strip()}')

				if fixScreen:
					if strings is not None:
						needsFixing = True
						if textMatch[2] in strings['String'].values:
							# This horrible looking line simply gets the index of the first occurrence
							# of textMatch[2] (i.e. the text that's in-between " & ") in the 'strings' DataFrame
							newID = strings.index.values[strings['String'] == textMatch[2]][0]

							print(f'Substituting "{textMatch[2]}" with ${newID}')
							# Replace the string with an existing string ID
							lines[i] = re.sub(textEntry, rf'\1text = "${newID}"', line)
							ids.append(int(newID))
						else:
							# Make a note of the string so that we can add it to the end of the dat file
							newStrings.append((i, textMatch[2]))

	if newStrings:
		newID = max(ids)
		for i, string in newStrings:
			# Generate an ID for the new string
			newID += 1
			lines[i] = re.sub(textEntry, rf'\1text = "${newID}"', lines[i])
			ids.append(int(newID))

			print(f'Assigning new ID [{newID}] for "{string}" (line {lNum(i)})')


	if fixScreen and needsFixing:
		print(f'[INFO] Fixing "{screen}"')
		with open(screen, 'w') as file:
			file.writelines(lines)

	return ids, newStrings


def getRange(ids):
	ids = list(set(ids))
	ids.sort()
	limits = roundRange(min(ids), max(ids))
	return ids, limits

def roundRange(_min, _max):
	# Round down to nearest fifty
	start = (_min // 50) * 50
	end   = (_max // 50) * 50

	# Round up unless it divides equally
	if (_max % 50) != 0: end += 50

	# The range has to end on 1 less than a multiple of 50
	end -= 1
	return (start, end)

def datFileHeader(name, limits):
	# Dat file boiler plate
	header = '/' * 69 + '\n'
	header += '// Generated with CLUIE\n\n'
	header += f'filerange {limits[0]} {limits[1]}\n\n'
	header += '/' * 69 + '\n' # nice
	header += f'// UI Screen: {name}\n\n'
	return header



if __name__ == "__main__":
	parser = argparse.ArgumentParser(description='Generate .dat file (for UI editor) from a .screen file')

	parser.add_argument('paths',
						nargs='+',
						help='Path to the screen file(s)')

	parser.add_argument('-d', '--dest',
						help='Destination for the .dat file',
						metavar='outPath')

	parser.add_argument('-l', '--locFile',
						help='File containing original strings',
						metavar='locFile')

	parser.add_argument('--fix', '--auto-fix',
						choices=[True, False],
						default=True,
						help='Whether to auto-fix the errors in the screen file')

	args = parser.parse_args()


	# Validate parameters
	if args.dest and not os.path.isdir(args.dest):
		print(f"[Error] Not a directory: {args.dest}")
		sys.exit()

	if args.locFile:
		if not os.path.isfile(args.locFile):
			print(f'[Error] File doesn\'t exist: {args.locFile}')
			sys.exit()

		elif not args.locFile.endswith('.ucs'):
			print(f'[Error] Not a localisation (.ucs) file: {args.locFile}')
			sys.exit()

	for path in args.paths:
		if os.path.isfile(path):
			if path.endswith('.screen'):
				GenerateDatFile(path, args.locFile, args.dest, args.fix)
			else:
				print('[Error] Not a screen file: {args.path}')

		elif os.path.isdir(path):
			print('DIR')

		else:
			print('[Error] The path specified does not exist')



